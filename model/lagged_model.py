import numpy as np
import warnings
from typing import Dict, Tuple, Optional, Any, List
from sklearn.base import clone
from model.base_model import BaseModel
from model.utils import create_matrices, ohe

class LaggedModel(BaseModel):
    """
    A generic framework for autoregressive forecasting using Scikit-Learn estimators.
    
    This class handles the construction of lag matrices ($X$) and targets ($Y$) to support 
    various forecasting strategies and panel structures, independent of the underlying 
    regression algorithm (e.g., Ridge, XGBoost).

    **Mathematical Formulation:**

    Let $y_{i,t} \in \mathbb{R}^K$ be the feature vector for entity $i$ at time $t$.
    The input regressor $x_{i,t}$ is formed by stacking $p$ lags: 
    $x_{i,t} = [y_{i,t-1}, \dots, y_{i,t-p}]$.

    **1. Strategies:**
    
    * **Recursive (Iterative):** Trains a single one-step-ahead estimator $f: x_{i,t} \to y_{i,t+1}$.
        Forecasts for horizon $h > 1$ are generated by recursively feeding predictions back as inputs:
        $$ \hat{y}_{i,T+h} = f(\hat{y}_{i,T+h-1}, \dots, \hat{y}_{i,T+h-p}) $$
        *Constraint:* Must model all $K$ features to enable recursion.

    * **Direct (Multi-Horizon):**
        Trains a separate estimator $f_h$ for each horizon step $h \in \{1, \dots, H\}$:
        $$ \hat{y}_{i,T+h} = f_h(y_{i,T}, \dots, y_{i,T-p+1}) $$
        *Advantage:* optimizing $f_h$ minimizes loss specifically for horizon $h$.

    **2. Structures:**
    
    * **Pooled:** A single global model $\theta$ is shared across all entities.
        Data is stacked: $X_{train} = \bigcup_i X_i$.
    * **Panel:** Independent parameters $\theta_i$ are estimated for each entity.
    """
    
    def __init__(self, config: dict):
        super().__init__(config)
        self.base_estimator = config.get('base_estimator')
        if self.base_estimator is None:
            raise ValueError("Config must provide a 'base_estimator'.")
            
        self.lags = config.get('lags', 1)
        self.structure = config.get('structure')
        self.strategy = config.get('strategy', 'recursive')
        self.trend = config.get('trend', 'c')
        self.verbose = config.get('verbose', False)
        self.ohe = config.get('ohe', False)
        self.seed = config.get('seed', 42)
        
        # Validations
        if self.structure not in ['panel', 'pooled']:
            raise ValueError("Structure must be 'panel' or 'pooled'.")
        if self.structure == 'panel' and self.ohe:
            warnings.warn("OHE ignored: not applicable in 'panel' structure.")
            self.ohe = False
            
        # Storage: scope -> {horizon: estimator}
        self.estimators: Dict[str, Dict[int, Any]] = {}

    def _fit_solver(self, X: np.ndarray, Y: np.ndarray) -> Any:
        """
        Fits the underlying estimator. Can be overridden for complex logic.
        """
        est = clone(self.base_estimator)
        est.fit(X, Y)
        return est

    def _predict_estimator(self, estimator: Any, X: np.ndarray) -> np.ndarray:
        """Safe prediction wrapper enforcing 2D output (N, Targets)."""
        preds = estimator.predict(X)
        if preds.ndim == 1:
            preds = preds.reshape(-1, 1)
        return preds

    def train_and_predict(
        self,
        data: Dict,
        horizon: int,
        train: bool = True
    ) -> Tuple[np.ndarray, Dict]:
        """
        Executes the training and forecasting pipeline.
        
        Args:
            data: Dictionary containing 'train' (time series) and 'meta' info.
            horizon: Forecasting steps ($H$).
            train: Whether to retrain models or use existing ones.
            
        Returns:
            preds: Array of shape (n_countries, horizon, n_targets).
        """
        np.random.seed(self.seed)

        countries = data['meta']['countries']
        target_cols = data['meta']['target_cols']
        feature_cols = list(data['meta']['features'])
        
        # indices to extract targets from full feature vector
        target_indices = [feature_cols.index(c) for c in target_cols]
        n_targets = len(target_cols)
        
        preds = np.full((len(countries), horizon, n_targets), np.nan)

        # ==========================
        # 1. DATA PREPARATION
        # ==========================
        # Map: scope (Country or 'GLOBAL') -> horizon -> (X, Y)
        train_tasks = {} 
        
        if train:
            # Recursive needs only h=1; Direct needs h=1..H
            horizons = range(1, horizon + 1) if self.strategy == 'direct' else [1]
            
            if self.structure == 'pooled':
                for h in horizons:
                    Xs, Ys = [], []
                    for i, c in enumerate(countries):
                        ts = data['train'].get(c)
                        if ts is None: continue
                        
                        x, y = create_matrices(self.lags, ts, look_ahead=h)
                        if x is None: continue
                            
                        if self.ohe:
                            x = ohe(x, i, len(countries))
                        
                        Xs.append(x)
                        # Recursive: Train on ALL features (needed for iteration)
                        # Direct: Train on TARGETS only (sufficient)
                        if self.strategy == 'recursive':
                            Ys.append(y)
                        else:
                            Ys.append(y[:, target_indices])
                    
                    if Xs:
                        train_tasks.setdefault('GLOBAL', {})[h] = (np.vstack(Xs), np.vstack(Ys))

            else: # Panel
                for c in countries:
                    ts = data['train'].get(c)
                    if ts is None: continue
                    
                    for h in horizons:
                        x, y = create_matrices(self.lags, ts, look_ahead=h)
                        if x is None: continue
                        
                        y_target = y if self.strategy == 'recursive' else y[:, target_indices]
                        train_tasks.setdefault(c, {})[h] = (x, y_target)

            # ==========================
            # 2. TRAINING
            # ==========================
            for scope, tasks in train_tasks.items():
                self.estimators[scope] = {}
                for h, (X_train, Y_train) in tasks.items():        
                    try:
                        self.estimators[scope][h] = self._fit_solver(X_train, Y_train)
                    except Exception as e:
                        if self.verbose: print(f"Fit Error {scope} h={h}: {e}")
                        self.estimators[scope][h] = None

        # ==========================
        # 3. PREDICTION
        # ==========================
        for i, c in enumerate(countries):
            ts = data['train'].get(c)
            if ts is None: continue
            
            scope = 'GLOBAL' if self.structure == 'pooled' else c
            if scope not in self.estimators: continue

            if len(ts) < self.lags:
                if self.verbose: print(f"Skip {c}: len {len(ts)} < lags {self.lags}")
                continue
            
            # Prepare initial input vector (last p observations, reversed)
            # Shape: (1, n_features * lags)
            curr_lags = ts[-self.lags:][::-1].reshape(1, -1)
            n_features = ts.shape[1]

            # A. Recursive Strategy
            if self.strategy == 'recursive':
                est = self.estimators[scope].get(1)
                if est is None: continue
                                
                for h in range(horizon):
                    X_in = ohe(curr_lags, i, len(countries)) if self.ohe else curr_lags
                    
                    # Predict all features
                    step_pred = self._predict_estimator(est, X_in) # (1, n_features)
                    
                    # Store targets
                    preds[i, h, :] = step_pred[0, target_indices]
                    
                    # Update state: Shift right, insert new prediction at start
                    # Assumes lags structure: [t, t-1, t-2...]
                    curr_lags = np.hstack([step_pred, curr_lags[:, :-n_features]])

            # B. Direct Strategy
            elif self.strategy == 'direct':
                X_in = ohe(curr_lags, i, len(countries)) if self.ohe else curr_lags
                
                for h in range(1, horizon + 1):
                    est = self.estimators[scope].get(h)
                    if est is None: continue
                    
                    # Predict targets directly
                    step_pred = self._predict_estimator(est, X_in) # (1, n_targets)
                    preds[i, h - 1, :] = step_pred[0, :]

        return preds, {}